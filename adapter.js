// AUTOGENERATED, DO NOT EDIT!
/* eslint-disable */

// facade/source.ts
import Worker from "__WORKER__";

// facade/connection.ts
if (!("OPEN" in WebSocket)) {
  const WebSocketStatus = {
    CONNECTING: WebSocket.READY_STATE_CONNECTING,
    OPEN: WebSocket.READY_STATE_OPEN,
    CLOSING: WebSocket.READY_STATE_CLOSING,
    CLOSED: WebSocket.READY_STATE_CLOSED,
  };
  Object.assign(WebSocket, WebSocketStatus);
  Object.assign(WebSocket.prototype, WebSocketStatus);
}
var AttachmentCache = class {
  _cache = /* @__PURE__ */ new WeakMap();
  get(ws) {
    let attachment = this._cache.get(ws);
    if (!attachment) {
      attachment = WebSocket.prototype.deserializeAttachment.call(ws);
      if (attachment !== void 0) {
        this._cache.set(ws, attachment);
      } else {
        throw new Error(
          "Missing websocket attachment. This is most likely an issue in PartyKit, please open an issue at https://github.com/partykit/partykit/issues"
        );
      }
    }
    return attachment;
  }
  set(ws, attachment) {
    this._cache.set(ws, attachment);
    WebSocket.prototype.serializeAttachment.call(ws, attachment);
  }
};
var attachments = new AttachmentCache();
var connections = /* @__PURE__ */ new WeakSet();
var isWrapped = (ws) => {
  return connections.has(ws);
};
var createLazyConnection = (ws) => {
  if (isWrapped(ws)) {
    return ws;
  }
  let initialState = void 0;
  if ("state" in ws) {
    initialState = ws.state;
    delete ws.state;
  }
  const connection = Object.defineProperties(ws, {
    id: {
      get() {
        return attachments.get(ws).__pk.id;
      },
    },
    uri: {
      get() {
        return attachments.get(ws).__pk.uri;
      },
    },
    socket: {
      get() {
        return ws;
      },
    },
    state: {
      get() {
        return this.deserializeAttachment();
      },
    },
    setState: {
      value: function setState(setState) {
        let state;
        if (setState instanceof Function) {
          state = setState(this.state);
        } else {
          state = setState;
        }
        this.serializeAttachment(state);
        return state;
      },
    },
    deserializeAttachment: {
      value: function deserializeAttachment() {
        const attachment = attachments.get(ws);
        return attachment?.__user ?? null;
      },
    },
    serializeAttachment: {
      value: function serializeAttachment(attachment) {
        const setting = {
          ...attachments.get(ws),
          __user: attachment ?? null,
        };
        attachments.set(ws, setting);
      },
    },
  });
  if (initialState) {
    connection.setState(initialState);
  }
  connections.add(connection);
  return connection;
};
var HibernatingConnectionIterator = class {
  constructor(state, tag) {
    this.state = state;
    this.tag = tag;
  }
  index = 0;
  sockets;
  [Symbol.iterator]() {
    return this;
  }
  next() {
    const sockets =
      this.sockets ?? (this.sockets = this.state.getWebSockets(this.tag));
    let socket;
    while ((socket = sockets[this.index++])) {
      if (socket.readyState === WebSocket.READY_STATE_OPEN) {
        const value = createLazyConnection(socket);
        return { done: false, value };
      }
    }
    return { done: true, value: void 0 };
  }
};
var InMemoryConnectionManager = class {
  connections = /* @__PURE__ */ new Map();
  tags = /* @__PURE__ */ new WeakMap();
  getCount() {
    return this.connections.size;
  }
  getConnection(id) {
    return this.connections.get(id);
  }
  *getConnections(tag) {
    if (!tag) {
      yield* this.connections.values();
      return;
    }
    for (const connection of this.connections.values()) {
      const connectionTags = this.tags.get(connection) ?? [];
      if (connectionTags.includes(tag)) {
        yield connection;
      }
    }
  }
  legacy_getConnectionMap() {
    return this.connections;
  }
  accept(connection, tags) {
    connection.accept();
    this.connections.set(connection.id, connection);
    this.tags.set(connection, [
      // make sure we have id tag
      connection.id,
      ...tags.filter((t) => t !== connection.id),
    ]);
    const removeConnection = () => {
      this.connections.delete(connection.id);
      connection.removeEventListener("close", removeConnection);
      connection.removeEventListener("error", removeConnection);
    };
    connection.addEventListener("close", removeConnection);
    connection.addEventListener("error", removeConnection);
    return connection;
  }
};
var HibernatingConnectionManager = class {
  constructor(controller) {
    this.controller = controller;
  }
  getCount() {
    return Number(this.controller.getWebSockets().length);
  }
  getConnection(id) {
    const sockets = this.controller.getWebSockets(id);
    if (sockets.length === 0) return void 0;
    if (sockets.length === 1) return createLazyConnection(sockets[0]);
    throw new Error(
      `More than one connection found for id ${id}. Did you mean to use getConnections(tag) instead?`
    );
  }
  getConnections(tag) {
    return new HibernatingConnectionIterator(this.controller, tag);
  }
  legacy_getConnectionMap() {
    const connections2 = /* @__PURE__ */ new Map();
    for (const connection of this.getConnections()) {
      connections2.set(connection.id, connection);
    }
    return connections2;
  }
  accept(connection, userTags) {
    const tags = [
      connection.id,
      ...userTags.filter((t) => t !== connection.id),
    ];
    if (tags.length > 10) {
      throw new Error(
        "A connection can only have 10 tags, including the default id tag."
      );
    }
    for (const tag of tags) {
      if (typeof tag !== "string") {
        throw new Error(`A connection tag must be a string. Received: ${tag}`);
      }
      if (tag === "") {
        throw new Error(`A connection tag must not be an empty string.`);
      }
      if (tag.length > 256) {
        throw new Error(`A connection tag must not exceed 256 characters`);
      }
    }
    this.controller.acceptWebSocket(connection, tags);
    connection.serializeAttachment({
      __pk: {
        id: connection.id,
        uri: connection.uri,
      },
      __user: null,
    });
    return createLazyConnection(connection);
  }
};

// facade/fetch-static-asset.ts
import StaticAssetManifest from "__STATIC_ASSETS_MANIFEST__";

// node_modules/mime/dist/types/standard.js
var types = {
  "application/andrew-inset": ["ez"],
  "application/appinstaller": ["appinstaller"],
  "application/applixware": ["aw"],
  "application/appx": ["appx"],
  "application/appxbundle": ["appxbundle"],
  "application/atom+xml": ["atom"],
  "application/atomcat+xml": ["atomcat"],
  "application/atomdeleted+xml": ["atomdeleted"],
  "application/atomsvc+xml": ["atomsvc"],
  "application/atsc-dwd+xml": ["dwd"],
  "application/atsc-held+xml": ["held"],
  "application/atsc-rsat+xml": ["rsat"],
  "application/automationml-aml+xml": ["aml"],
  "application/automationml-amlx+zip": ["amlx"],
  "application/bdoc": ["bdoc"],
  "application/calendar+xml": ["xcs"],
  "application/ccxml+xml": ["ccxml"],
  "application/cdfx+xml": ["cdfx"],
  "application/cdmi-capability": ["cdmia"],
  "application/cdmi-container": ["cdmic"],
  "application/cdmi-domain": ["cdmid"],
  "application/cdmi-object": ["cdmio"],
  "application/cdmi-queue": ["cdmiq"],
  "application/cpl+xml": ["cpl"],
  "application/cu-seeme": ["cu"],
  "application/cwl": ["cwl"],
  "application/dash+xml": ["mpd"],
  "application/dash-patch+xml": ["mpp"],
  "application/davmount+xml": ["davmount"],
  "application/docbook+xml": ["dbk"],
  "application/dssc+der": ["dssc"],
  "application/dssc+xml": ["xdssc"],
  "application/ecmascript": ["ecma"],
  "application/emma+xml": ["emma"],
  "application/emotionml+xml": ["emotionml"],
  "application/epub+zip": ["epub"],
  "application/exi": ["exi"],
  "application/express": ["exp"],
  "application/fdf": ["fdf"],
  "application/fdt+xml": ["fdt"],
  "application/font-tdpfr": ["pfr"],
  "application/geo+json": ["geojson"],
  "application/gml+xml": ["gml"],
  "application/gpx+xml": ["gpx"],
  "application/gxf": ["gxf"],
  "application/gzip": ["gz"],
  "application/hjson": ["hjson"],
  "application/hyperstudio": ["stk"],
  "application/inkml+xml": ["ink", "inkml"],
  "application/ipfix": ["ipfix"],
  "application/its+xml": ["its"],
  "application/java-archive": ["jar", "war", "ear"],
  "application/java-serialized-object": ["ser"],
  "application/java-vm": ["class"],
  "application/javascript": ["*js"],
  "application/json": ["json", "map"],
  "application/json5": ["json5"],
  "application/jsonml+json": ["jsonml"],
  "application/ld+json": ["jsonld"],
  "application/lgr+xml": ["lgr"],
  "application/lost+xml": ["lostxml"],
  "application/mac-binhex40": ["hqx"],
  "application/mac-compactpro": ["cpt"],
  "application/mads+xml": ["mads"],
  "application/manifest+json": ["webmanifest"],
  "application/marc": ["mrc"],
  "application/marcxml+xml": ["mrcx"],
  "application/mathematica": ["ma", "nb", "mb"],
  "application/mathml+xml": ["mathml"],
  "application/mbox": ["mbox"],
  "application/media-policy-dataset+xml": ["mpf"],
  "application/mediaservercontrol+xml": ["mscml"],
  "application/metalink+xml": ["metalink"],
  "application/metalink4+xml": ["meta4"],
  "application/mets+xml": ["mets"],
  "application/mmt-aei+xml": ["maei"],
  "application/mmt-usd+xml": ["musd"],
  "application/mods+xml": ["mods"],
  "application/mp21": ["m21", "mp21"],
  "application/mp4": ["*mp4", "*mpg4", "mp4s", "m4p"],
  "application/msix": ["msix"],
  "application/msixbundle": ["msixbundle"],
  "application/msword": ["doc", "dot"],
  "application/mxf": ["mxf"],
  "application/n-quads": ["nq"],
  "application/n-triples": ["nt"],
  "application/node": ["cjs"],
  "application/octet-stream": [
    "bin",
    "dms",
    "lrf",
    "mar",
    "so",
    "dist",
    "distz",
    "pkg",
    "bpk",
    "dump",
    "elc",
    "deploy",
    "exe",
    "dll",
    "deb",
    "dmg",
    "iso",
    "img",
    "msi",
    "msp",
    "msm",
    "buffer",
  ],
  "application/oda": ["oda"],
  "application/oebps-package+xml": ["opf"],
  "application/ogg": ["ogx"],
  "application/omdoc+xml": ["omdoc"],
  "application/onenote": ["onetoc", "onetoc2", "onetmp", "onepkg"],
  "application/oxps": ["oxps"],
  "application/p2p-overlay+xml": ["relo"],
  "application/patch-ops-error+xml": ["xer"],
  "application/pdf": ["pdf"],
  "application/pgp-encrypted": ["pgp"],
  "application/pgp-keys": ["asc"],
  "application/pgp-signature": ["sig", "*asc"],
  "application/pics-rules": ["prf"],
  "application/pkcs10": ["p10"],
  "application/pkcs7-mime": ["p7m", "p7c"],
  "application/pkcs7-signature": ["p7s"],
  "application/pkcs8": ["p8"],
  "application/pkix-attr-cert": ["ac"],
  "application/pkix-cert": ["cer"],
  "application/pkix-crl": ["crl"],
  "application/pkix-pkipath": ["pkipath"],
  "application/pkixcmp": ["pki"],
  "application/pls+xml": ["pls"],
  "application/postscript": ["ai", "eps", "ps"],
  "application/provenance+xml": ["provx"],
  "application/pskc+xml": ["pskcxml"],
  "application/raml+yaml": ["raml"],
  "application/rdf+xml": ["rdf", "owl"],
  "application/reginfo+xml": ["rif"],
  "application/relax-ng-compact-syntax": ["rnc"],
  "application/resource-lists+xml": ["rl"],
  "application/resource-lists-diff+xml": ["rld"],
  "application/rls-services+xml": ["rs"],
  "application/route-apd+xml": ["rapd"],
  "application/route-s-tsid+xml": ["sls"],
  "application/route-usd+xml": ["rusd"],
  "application/rpki-ghostbusters": ["gbr"],
  "application/rpki-manifest": ["mft"],
  "application/rpki-roa": ["roa"],
  "application/rsd+xml": ["rsd"],
  "application/rss+xml": ["rss"],
  "application/rtf": ["rtf"],
  "application/sbml+xml": ["sbml"],
  "application/scvp-cv-request": ["scq"],
  "application/scvp-cv-response": ["scs"],
  "application/scvp-vp-request": ["spq"],
  "application/scvp-vp-response": ["spp"],
  "application/sdp": ["sdp"],
  "application/senml+xml": ["senmlx"],
  "application/sensml+xml": ["sensmlx"],
  "application/set-payment-initiation": ["setpay"],
  "application/set-registration-initiation": ["setreg"],
  "application/shf+xml": ["shf"],
  "application/sieve": ["siv", "sieve"],
  "application/smil+xml": ["smi", "smil"],
  "application/sparql-query": ["rq"],
  "application/sparql-results+xml": ["srx"],
  "application/sql": ["sql"],
  "application/srgs": ["gram"],
  "application/srgs+xml": ["grxml"],
  "application/sru+xml": ["sru"],
  "application/ssdl+xml": ["ssdl"],
  "application/ssml+xml": ["ssml"],
  "application/swid+xml": ["swidtag"],
  "application/tei+xml": ["tei", "teicorpus"],
  "application/thraud+xml": ["tfi"],
  "application/timestamped-data": ["tsd"],
  "application/toml": ["toml"],
  "application/trig": ["trig"],
  "application/ttml+xml": ["ttml"],
  "application/ubjson": ["ubj"],
  "application/urc-ressheet+xml": ["rsheet"],
  "application/urc-targetdesc+xml": ["td"],
  "application/voicexml+xml": ["vxml"],
  "application/wasm": ["wasm"],
  "application/watcherinfo+xml": ["wif"],
  "application/widget": ["wgt"],
  "application/winhlp": ["hlp"],
  "application/wsdl+xml": ["wsdl"],
  "application/wspolicy+xml": ["wspolicy"],
  "application/xaml+xml": ["xaml"],
  "application/xcap-att+xml": ["xav"],
  "application/xcap-caps+xml": ["xca"],
  "application/xcap-diff+xml": ["xdf"],
  "application/xcap-el+xml": ["xel"],
  "application/xcap-ns+xml": ["xns"],
  "application/xenc+xml": ["xenc"],
  "application/xfdf": ["xfdf"],
  "application/xhtml+xml": ["xhtml", "xht"],
  "application/xliff+xml": ["xlf"],
  "application/xml": ["xml", "xsl", "xsd", "rng"],
  "application/xml-dtd": ["dtd"],
  "application/xop+xml": ["xop"],
  "application/xproc+xml": ["xpl"],
  "application/xslt+xml": ["*xsl", "xslt"],
  "application/xspf+xml": ["xspf"],
  "application/xv+xml": ["mxml", "xhvml", "xvml", "xvm"],
  "application/yang": ["yang"],
  "application/yin+xml": ["yin"],
  "application/zip": ["zip"],
  "audio/3gpp": ["*3gpp"],
  "audio/aac": ["adts", "aac"],
  "audio/adpcm": ["adp"],
  "audio/amr": ["amr"],
  "audio/basic": ["au", "snd"],
  "audio/midi": ["mid", "midi", "kar", "rmi"],
  "audio/mobile-xmf": ["mxmf"],
  "audio/mp3": ["*mp3"],
  "audio/mp4": ["m4a", "mp4a"],
  "audio/mpeg": ["mpga", "mp2", "mp2a", "mp3", "m2a", "m3a"],
  "audio/ogg": ["oga", "ogg", "spx", "opus"],
  "audio/s3m": ["s3m"],
  "audio/silk": ["sil"],
  "audio/wav": ["wav"],
  "audio/wave": ["*wav"],
  "audio/webm": ["weba"],
  "audio/xm": ["xm"],
  "font/collection": ["ttc"],
  "font/otf": ["otf"],
  "font/ttf": ["ttf"],
  "font/woff": ["woff"],
  "font/woff2": ["woff2"],
  "image/aces": ["exr"],
  "image/apng": ["apng"],
  "image/avci": ["avci"],
  "image/avcs": ["avcs"],
  "image/avif": ["avif"],
  "image/bmp": ["bmp", "dib"],
  "image/cgm": ["cgm"],
  "image/dicom-rle": ["drle"],
  "image/dpx": ["dpx"],
  "image/emf": ["emf"],
  "image/fits": ["fits"],
  "image/g3fax": ["g3"],
  "image/gif": ["gif"],
  "image/heic": ["heic"],
  "image/heic-sequence": ["heics"],
  "image/heif": ["heif"],
  "image/heif-sequence": ["heifs"],
  "image/hej2k": ["hej2"],
  "image/hsj2": ["hsj2"],
  "image/ief": ["ief"],
  "image/jls": ["jls"],
  "image/jp2": ["jp2", "jpg2"],
  "image/jpeg": ["jpeg", "jpg", "jpe"],
  "image/jph": ["jph"],
  "image/jphc": ["jhc"],
  "image/jpm": ["jpm", "jpgm"],
  "image/jpx": ["jpx", "jpf"],
  "image/jxr": ["jxr"],
  "image/jxra": ["jxra"],
  "image/jxrs": ["jxrs"],
  "image/jxs": ["jxs"],
  "image/jxsc": ["jxsc"],
  "image/jxsi": ["jxsi"],
  "image/jxss": ["jxss"],
  "image/ktx": ["ktx"],
  "image/ktx2": ["ktx2"],
  "image/png": ["png"],
  "image/sgi": ["sgi"],
  "image/svg+xml": ["svg", "svgz"],
  "image/t38": ["t38"],
  "image/tiff": ["tif", "tiff"],
  "image/tiff-fx": ["tfx"],
  "image/webp": ["webp"],
  "image/wmf": ["wmf"],
  "message/disposition-notification": ["disposition-notification"],
  "message/global": ["u8msg"],
  "message/global-delivery-status": ["u8dsn"],
  "message/global-disposition-notification": ["u8mdn"],
  "message/global-headers": ["u8hdr"],
  "message/rfc822": ["eml", "mime"],
  "model/3mf": ["3mf"],
  "model/gltf+json": ["gltf"],
  "model/gltf-binary": ["glb"],
  "model/iges": ["igs", "iges"],
  "model/jt": ["jt"],
  "model/mesh": ["msh", "mesh", "silo"],
  "model/mtl": ["mtl"],
  "model/obj": ["obj"],
  "model/prc": ["prc"],
  "model/step+xml": ["stpx"],
  "model/step+zip": ["stpz"],
  "model/step-xml+zip": ["stpxz"],
  "model/stl": ["stl"],
  "model/u3d": ["u3d"],
  "model/vrml": ["wrl", "vrml"],
  "model/x3d+binary": ["*x3db", "x3dbz"],
  "model/x3d+fastinfoset": ["x3db"],
  "model/x3d+vrml": ["*x3dv", "x3dvz"],
  "model/x3d+xml": ["x3d", "x3dz"],
  "model/x3d-vrml": ["x3dv"],
  "text/cache-manifest": ["appcache", "manifest"],
  "text/calendar": ["ics", "ifb"],
  "text/coffeescript": ["coffee", "litcoffee"],
  "text/css": ["css"],
  "text/csv": ["csv"],
  "text/html": ["html", "htm", "shtml"],
  "text/jade": ["jade"],
  "text/javascript": ["js", "mjs"],
  "text/jsx": ["jsx"],
  "text/less": ["less"],
  "text/markdown": ["md", "markdown"],
  "text/mathml": ["mml"],
  "text/mdx": ["mdx"],
  "text/n3": ["n3"],
  "text/plain": ["txt", "text", "conf", "def", "list", "log", "in", "ini"],
  "text/richtext": ["rtx"],
  "text/rtf": ["*rtf"],
  "text/sgml": ["sgml", "sgm"],
  "text/shex": ["shex"],
  "text/slim": ["slim", "slm"],
  "text/spdx": ["spdx"],
  "text/stylus": ["stylus", "styl"],
  "text/tab-separated-values": ["tsv"],
  "text/troff": ["t", "tr", "roff", "man", "me", "ms"],
  "text/turtle": ["ttl"],
  "text/uri-list": ["uri", "uris", "urls"],
  "text/vcard": ["vcard"],
  "text/vtt": ["vtt"],
  "text/wgsl": ["wgsl"],
  "text/xml": ["*xml"],
  "text/yaml": ["yaml", "yml"],
  "video/3gpp": ["3gp", "3gpp"],
  "video/3gpp2": ["3g2"],
  "video/h261": ["h261"],
  "video/h263": ["h263"],
  "video/h264": ["h264"],
  "video/iso.segment": ["m4s"],
  "video/jpeg": ["jpgv"],
  "video/jpm": ["*jpm", "*jpgm"],
  "video/mj2": ["mj2", "mjp2"],
  "video/mp2t": ["ts"],
  "video/mp4": ["mp4", "mp4v", "mpg4"],
  "video/mpeg": ["mpeg", "mpg", "mpe", "m1v", "m2v"],
  "video/ogg": ["ogv"],
  "video/quicktime": ["qt", "mov"],
  "video/webm": ["webm"],
};
Object.freeze(types);
var standard_default = types;

// node_modules/mime/dist/src/Mime.js
var __classPrivateFieldGet = function (receiver, state, kind, f) {
  if (kind === "a" && !f)
    throw new TypeError("Private accessor was defined without a getter");
  if (
    typeof state === "function"
      ? receiver !== state || !f
      : !state.has(receiver)
  )
    throw new TypeError(
      "Cannot read private member from an object whose class did not declare it"
    );
  return kind === "m"
    ? f
    : kind === "a"
    ? f.call(receiver)
    : f
    ? f.value
    : state.get(receiver);
};
var _Mime_extensionToType;
var _Mime_typeToExtension;
var _Mime_typeToExtensions;
var Mime = class {
  constructor(...args) {
    _Mime_extensionToType.set(this, /* @__PURE__ */ new Map());
    _Mime_typeToExtension.set(this, /* @__PURE__ */ new Map());
    _Mime_typeToExtensions.set(this, /* @__PURE__ */ new Map());
    for (const arg of args) {
      this.define(arg);
    }
  }
  define(typeMap, force = false) {
    for (let [type, extensions] of Object.entries(typeMap)) {
      type = type.toLowerCase();
      extensions = extensions.map((ext) => ext.toLowerCase());
      if (
        !__classPrivateFieldGet(this, _Mime_typeToExtensions, "f").has(type)
      ) {
        __classPrivateFieldGet(this, _Mime_typeToExtensions, "f").set(
          type,
          /* @__PURE__ */ new Set()
        );
      }
      const allExtensions = __classPrivateFieldGet(
        this,
        _Mime_typeToExtensions,
        "f"
      ).get(type);
      let first = true;
      for (let extension of extensions) {
        const starred = extension.startsWith("*");
        extension = starred ? extension.slice(1) : extension;
        allExtensions?.add(extension);
        if (first) {
          __classPrivateFieldGet(this, _Mime_typeToExtension, "f").set(
            type,
            extension
          );
        }
        first = false;
        if (starred) continue;
        const currentType = __classPrivateFieldGet(
          this,
          _Mime_extensionToType,
          "f"
        ).get(extension);
        if (currentType && currentType != type && !force) {
          throw new Error(
            `"${type} -> ${extension}" conflicts with "${currentType} -> ${extension}". Pass \`force=true\` to override this definition.`
          );
        }
        __classPrivateFieldGet(this, _Mime_extensionToType, "f").set(
          extension,
          type
        );
      }
    }
    return this;
  }
  getType(path) {
    if (typeof path !== "string") return null;
    const last = path.replace(/^.*[/\\]/, "").toLowerCase();
    const ext = last.replace(/^.*\./, "").toLowerCase();
    const hasPath = last.length < path.length;
    const hasDot = ext.length < last.length - 1;
    if (!hasDot && hasPath) return null;
    return (
      __classPrivateFieldGet(this, _Mime_extensionToType, "f").get(ext) ?? null
    );
  }
  getExtension(type) {
    if (typeof type !== "string") return null;
    type = type?.split?.(";")[0];
    return (
      (type &&
        __classPrivateFieldGet(this, _Mime_typeToExtension, "f").get(
          type.trim().toLowerCase()
        )) ??
      null
    );
  }
  getAllExtensions(type) {
    if (typeof type !== "string") return null;
    return (
      __classPrivateFieldGet(this, _Mime_typeToExtensions, "f").get(
        type.toLowerCase()
      ) ?? null
    );
  }
  _freeze() {
    this.define = () => {
      throw new Error(
        "define() not allowed for built-in Mime objects. See https://github.com/broofa/mime/blob/main/README.md#custom-mime-instances"
      );
    };
    Object.freeze(this);
    for (const extensions of __classPrivateFieldGet(
      this,
      _Mime_typeToExtensions,
      "f"
    ).values()) {
      Object.freeze(extensions);
    }
    return this;
  }
  _getTestState() {
    return {
      types: __classPrivateFieldGet(this, _Mime_extensionToType, "f"),
      extensions: __classPrivateFieldGet(this, _Mime_typeToExtension, "f"),
    };
  }
};
(_Mime_extensionToType = /* @__PURE__ */ new WeakMap()),
  (_Mime_typeToExtension = /* @__PURE__ */ new WeakMap()),
  (_Mime_typeToExtensions = /* @__PURE__ */ new WeakMap());
var Mime_default = Mime;

// node_modules/mime/dist/src/index_lite.js
var index_lite_default = new Mime_default(standard_default)._freeze();

// facade/fetch-static-asset.ts
function getRoomAndPartyFromPathname(pathname) {
  if (pathname.startsWith("/party/")) {
    const [_, __, roomId] = pathname.split("/");
    return {
      room: roomId,
      party: "main",
    };
  } else if (pathname.startsWith("/parties/")) {
    const [_, __, partyName, roomId] = pathname.split("/");
    return {
      room: roomId,
      party: partyName,
    };
  }
  return null;
}
async function fetchStaticAsset(request, _env, _ctx) {
  const SUPPORTED_METHODS = ["GET", "HEAD"];
  if (!SUPPORTED_METHODS.includes(request.method) || import.meta.env.DEV) {
    return null;
  }
  const url = new URL(request.url);
  let response = null;
  try {
    const { getAssetFromKV, MethodNotAllowedError, NotFoundError } =
      await import("@cloudflare/kv-asset-handler");
    const temp = await getAssetFromKV(
      {
        request,
        waitUntil(promise) {
          return _ctx.waitUntil(promise);
        },
      },
      {
        ASSET_NAMESPACE: _env.__STATIC_CONTENT,
        ASSET_MANIFEST: StaticAssetManifest.assets,
      }
    );
    if (temp.ok) {
      response = temp;
    }
  } catch (e) {
    if (e instanceof NotFoundError) {
      // ...
    } else if (e instanceof MethodNotAllowedError) {
      // ...
    } else {
      return new Response("An unexpected error occurred", { status: 500 });
    }
  }
  return response;
  // let filePath = decodeURIComponent(url.pathname);
  // if (filePath.endsWith("/")) {
  //   filePath += "index.html";
  // }
  // if (filePath !== "/" && filePath.startsWith("/")) {
  //   filePath = filePath.substring(1);
  // }
  // if (filePath in StaticAssetManifest.assets) {
  //   response = await fetch(
  //     `${StaticAssetManifest.devServer}/${StaticAssetManifest.assets[filePath]}`
  //   );
  // }
  // if (StaticAssetManifest.singlePageApp === true && response === null && request.headers.get("Sec-Fetch-Mode") === "navigate") {
  //   const { room: roomId } = getRoomAndPartyFromPathname(`/${filePath}`) || {};
  //   if (!roomId) {
  //     response = await fetch(
  //       `${StaticAssetManifest.devServer}/${StaticAssetManifest.assets["index.html"]}`
  //     );
  //   } else if (filePath.endsWith(".html")) {
  //     response = await fetch(
  //       `${StaticAssetManifest.devServer}/${StaticAssetManifest.assets["index.html"]}`
  //     );
  //   } else if (!index_lite_default.getType(filePath)) {
  //     response = await fetch(
  //       `${StaticAssetManifest.devServer}/${StaticAssetManifest.assets["index.html"]}`
  //     );
  //   }
  // }
  // return response;
}

// facade/vectorize.ts
async function fetchResult(api, options) {
  const { extraHeaders, ...fetchOptions } = options;
  const res = await fetch(`${PARTYKIT_API_BASE}${api}`, {
    ...fetchOptions,
    headers: {
      ...extraHeaders,
      ...fetchOptions.headers,
    },
  });
  if (res.ok) {
    const resJson = await res.json();
    return resJson;
  } else {
    let errorText;
    try {
      errorText = await res.text();
    } catch (e) {
      errorText = `${res.status} ${res.statusText}`;
    }
    throw new Error(errorText);
  }
}
var VECTORIZE_MAX_BATCH_SIZE = 1e3;
var VECTORIZE_UPSERT_BATCH_SIZE = VECTORIZE_MAX_BATCH_SIZE;
var VECTORIZE_MAX_UPSERT_VECTOR_RECORDS = 1e5;
async function* getBatchFromArray(
  array,
  batchSize = VECTORIZE_UPSERT_BATCH_SIZE
) {
  let batch = [];
  for await (const line of array) {
    if (batch.push(JSON.stringify(line)) >= batchSize) {
      yield batch;
      batch = [];
    }
  }
  yield batch;
}
var VectorizeClient = class {
  headers;
  namespace;
  index_name;
  constructor(options) {
    this.index_name = options.index_name;
    this.headers = options.headers;
    this.namespace = options.namespace;
  }
  fetch(api, init) {
    return fetchResult(api, { ...init, extraHeaders: this.headers });
  }
  describe() {
    return this.fetch(
      `/vectorize/${this.namespace}/indexes/${this.index_name}`,
      {
        method: "GET",
      }
    );
  }
  async query(vector, options) {
    return this.fetch(
      `/vectorize/${this.namespace}/indexes/${this.index_name}/query`,
      {
        method: "POST",
        body: JSON.stringify({
          vector,
          ...options,
        }),
        headers: {
          "Content-Type": "application/json",
        },
      }
    );
  }
  async insert(vectors, upsert = false) {
    let vectorInsertCount = 0;
    const insertedIds = [];
    for await (const batch of getBatchFromArray(vectors)) {
      const formData = new FormData();
      formData.append(
        "vectors",
        new File(
          [
            batch.join(`
`),
          ],
          "vectors.ndjson",
          {
            type: "application/x-ndjson",
          }
        )
      );
      const idxPart = await this.fetch(
        `/vectorize/${this.namespace}/indexes/${this.index_name}/${
          upsert ? "upsert" : "insert"
        }`,
        {
          method: "POST",
          body: formData,
        }
      );
      vectorInsertCount += idxPart.count;
      insertedIds.push(...idxPart.ids);
      if (vectorInsertCount > VECTORIZE_MAX_UPSERT_VECTOR_RECORDS) {
        console.warn(
          `\u{1F6A7} While Vectorize is in beta, we've limited uploads to 100k vectors per run. You may run this again with another batch to upload further`
        );
        break;
      }
    }
    return {
      count: vectorInsertCount,
      ids: insertedIds,
    };
  }
  async upsert(vectors) {
    return this.insert(vectors, true);
  }
  async deleteByIds(_ids) {
    throw new Error(
      "This method is not implemented in local dev, but will work when deployed"
    );
  }
  async getByIds(_ids) {
    throw new Error(
      "This method is not implemented in local dev, but will work when deployed."
    );
  }
};

// facade/worker.ts
var ModuleWorker = class {
  constructor(worker, room) {
    this.worker = worker;
    console.log("NEW WORKER");
    this.room = room;
    this.supportsHibernation =
      "onMessage" in worker || !(`onConnect` in worker);
  }
  options = {};
  supportsHibernation;
  onStart() {}
  onConnect(ws, ctx) {
    if (this.worker.onConnect) {
      return this.worker.onConnect(ws, this.room, ctx);
    }
  }
  onMessage(message, ws) {
    if (this.worker.onMessage) {
      return this.worker.onMessage(message, ws, this.room);
    }
  }
  onClose(ws) {
    if (this.worker.onClose) {
      return this.worker.onClose(ws, this.room);
    }
  }
  onError(ws, err) {
    if (this.worker.onError) {
      return this.worker.onError(ws, err, this.room);
    }
  }
  onRequest(req) {
    if (this.worker.onRequest) {
      return this.worker.onRequest(req, this.room);
    }
    return new Response("Invalid onRequest handler", {
      status: 500,
    });
  }
  onAlarm() {
    if (this.worker.onAlarm) {
      return this.worker.onAlarm(this.room);
    }
  }
  getConnectionTags() {
    return [];
  }
};
var ClassWorker = class {
  constructor(Worker2, room) {
    this.Worker = Worker2;
    this.room = room;
    this.worker = new Worker2(room);
    this.options = this.worker.options ?? {};
    this.supportsHibernation = this.options.hibernate === true;
  }
  worker;
  options;
  supportsHibernation;
  onStart() {
    if (this.worker.onStart) {
      return this.worker.onStart();
    }
  }
  onConnect(ws, ctx) {
    if (this.worker.onConnect) {
      return this.worker.onConnect(ws, ctx);
    }
  }
  onMessage(message, ws) {
    if (this.worker.onMessage) {
      return this.worker.onMessage(message, ws);
    }
  }
  onClose(ws) {
    if (this.worker.onClose) {
      return this.worker.onClose(ws);
    }
  }
  onError(ws, err) {
    if (this.worker.onError) {
      return this.worker.onError(ws, err);
    }
  }
  onRequest(req) {
    if (this.worker.onRequest) {
      return this.worker.onRequest(req);
    }
    return new Response("Invalid onRequest handler", {
      status: 500,
    });
  }
  onAlarm() {
    if (this.worker.onAlarm) {
      return this.worker.onAlarm();
    }
  }
  getConnectionTags(connection, context) {
    if (this.worker.getConnectionTags) {
      return this.worker.getConnectionTags(connection, context);
    }
    return [];
  }
};

// facade/source.ts
function assert(condition, msg) {
  if (!condition) {
    throw new Error(msg);
  }
}
var didWarnAboutDevAnalytics = false;
var MockAnalyticsDataset = {
  writeDataPoint: (_data) => {
    if (!didWarnAboutDevAnalytics) {
      console.log(
        "\u26A0\uFE0F  analytics.writeDataPoint is not implemented in local development."
      );
      didWarnAboutDevAnalytics = true;
    }
  },
};
function getRoomAndPartyFromPathname2(pathname) {
  if (pathname.startsWith("/party/")) {
    const [_, __, roomId] = pathname.split("/");
    return {
      room: roomId,
      party: "main",
    };
  } else if (pathname.startsWith("/parties/")) {
    const [_, __, partyName, roomId] = pathname.split("/");
    return {
      room: roomId,
      party: partyName,
    };
  }
  return null;
}
function isClassWorker(worker) {
  return (
    typeof worker === "function" &&
    "prototype" in worker &&
    worker.prototype instanceof Object
  );
}
function getBindings(env) {
  const r2Bindings = __R2_BINDINGS__;
  const kvBindings = __KV_BINDINGS__;
  return {
    r2: r2Bindings.reduce((acc, name) => {
      acc[name] = env[name];
      return acc;
    }, {}),
    kv: kvBindings.reduce((acc, name) => {
      acc[name] = env[name];
      return acc;
    }, {}),
  };
}
var PartyDurable = class {};
var parties;
function extractVars(obj) {
  const vars = {};
  for (const [key, value] of Object.entries(obj)) {
    if (key.startsWith("pkvar-")) {
      vars[key.slice(`pkvar-`.length)] = value;
    }
  }
  return vars;
}
function createMultiParties(namespaces, options) {
  if (!parties) {
    parties = {};
    for (const [key, value] of Object.entries(namespaces)) {
      if (typeof value.idFromName === "function") {
        parties[key] ||= {
          get: (name) => {
            const docId = value.idFromName(name).toString();
            const id = value.idFromString(docId);
            const stub = value.get(id);
            return {
              fetch(pathOrInit, maybeInit) {
                let path;
                let init;
                if (pathOrInit) {
                  if (typeof pathOrInit === "string") {
                    path = pathOrInit;
                    init = maybeInit;
                    if (path[0] !== "/") {
                      throw new Error("Path must start with /");
                    }
                    return stub.fetch(
                      `http://${options.host}/parties/${key}/${name}${path}`,
                      init
                    );
                  } else {
                    init = pathOrInit;
                    return stub.fetch(
                      `http://${options.host}/parties/${key}/${name}`,
                      init
                    );
                  }
                } else {
                  return stub.fetch(
                    `http://${options.host}/parties/${key}/${name}`
                  );
                }
              },
              connect: () => {
                return new WebSocket(
                  `ws://${options.host}/parties/${key}/${name}`
                );
              },
              async socket(pathOrInit, maybeInit) {
                let res;
                let path;
                let init;
                if (pathOrInit) {
                  if (typeof pathOrInit === "string") {
                    path = pathOrInit;
                    init = maybeInit;
                    if (path[0] !== "/") {
                      throw new Error("Path must start with /");
                    }
                    res = await stub.fetch(
                      `http://${options.host}/parties/${key}/${name}${path}`,
                      {
                        ...init,
                        headers: {
                          upgrade: "websocket",
                          ...init?.headers,
                        },
                      }
                    );
                  } else {
                    init = pathOrInit;
                    res = await stub.fetch(
                      `http://${options.host}/parties/${key}/${name}`,
                      {
                        ...init,
                        headers: {
                          upgrade: "websocket",
                          ...init?.headers,
                        },
                      }
                    );
                  }
                } else {
                  res = await stub.fetch(
                    `http://${options.host}/parties/${key}/${name}`,
                    {
                      headers: {
                        upgrade: "websocket",
                      },
                    }
                  );
                }
                const ws = res.webSocket;
                if (!ws) {
                  throw new Error("Expected a websocket response");
                }
                ws.accept();
                return ws;
              },
            };
          },
        };
      }
    }
  }
  return parties;
}
async function assetsFetch(path, env, ctx) {
  if (!path.startsWith("/")) {
    throw new Error("Path must start with /");
  }
  return fetchStaticAsset(new Request(`http://dummy.com${path}`), env, ctx);
}
function createDurable(Worker2, options) {
  console.log("Creating Durable");
  let isClassAPI;
  let WorkerInstanceMethods;
  return class extends PartyDurable {
    controller;
    room;
    namespaces;
    inAlarm = false;
    // used to prevent access to certain properties in onAlarm
    // assigned when first connection is received
    id;
    worker;
    parties;
    vectorize;
    connectionManager;
    constructor(controller, env) {
      super();
      isClassAPI = isClassWorker(Worker2);
      WorkerInstanceMethods = isClassWorker(Worker2)
        ? Worker2.prototype
        : Worker2;
      for (const handler of [
        "onConnect",
        "onRequest",
        "onMessage",
        "onClose",
        "onError",
        "onAlarm",
      ]) {
        if (handler in Worker2 && typeof Worker2[handler] !== "function") {
          throw new Error(`.${handler} should be a function`);
        }
      }
      for (const handler of [
        "unstable_onFetch",
        "onFetch",
        "onBeforeConnect",
        "onBeforeRequest",
      ]) {
        if (handler in WorkerInstanceMethods) {
          if (isClassAPI) {
            console.warn(
              `.${handler} is present on the class instance, but it should be defined as a static method`
            );
          }
          if (typeof WorkerInstanceMethods[handler] !== "function") {
            throw new Error(`.${handler} should be a function`);
          }
        }
      }

      const {
        PARTYKIT_AI,
        PARTYKIT_DURABLE,
        PARTYKIT_VECTORIZE,
        ...namespaces
      } = env;
      this.controller = controller;
      this.namespaces = namespaces;
      Object.assign(this.namespaces, {
        main: PARTYKIT_DURABLE,
      });
      this.vectorize = Object.fromEntries(
        Object.entries(PARTYKIT_VECTORIZE || {}).map(([key, value]) => [
          key,
          new VectorizeClient(value),
        ])
      );
      const self = this;
      this.room = {
        get id() {
          if (self.inAlarm) {
            throw new Error(
              "You can not access `Party.id` in the `onAlarm` handler.\nThis is a known limitation, and may be fixed in a future version of PartyKit.\nIf you access to the id, you can save it into the Room storage when setting the alarm.\n"
            );
          }
          if (self.id) {
            return self.id;
          }
          throw new Error(
            "Party.id is not yet initialized. This is probably a bug in PartyKit."
          );
        },
        internalID: this.controller.id.toString(),
        name: options.name,
        env: extractVars(env),
        storage: this.controller.storage,
        blockConcurrencyWhile: this.controller.blockConcurrencyWhile.bind(
          this.controller
        ),
        broadcast: this.broadcast,
        context: {
          get parties() {
            if (self.inAlarm) {
              throw new Error(
                "You can not access `Party.context.parties` in the `onAlarm` handler.\nThis is a known limitation, and may be fixed in a future version of PartyKit."
              );
            }
            if (self.parties) {
              return self.parties;
            }
            throw new Error(
              "Parties are not yet initialized. This is probably a bug in PartyKit."
            );
          },
          vectorize: this.vectorize,
          ai: PARTYKIT_AI,
          assets: {
            fetch(path) {
              return assetsFetch(path, env, {
                passThroughOnException() {},
                waitUntil(_promise) {},
              });
            },
          },
          bindings: getBindings(env),
        },
        getConnection(id) {
          if (self.connectionManager) {
            return self.connectionManager.getConnection(id);
          }
          console.warn(
            ".getConnection was invoked before first connection. This will always return undefined."
          );
          return void 0;
        },
        getConnections(tag) {
          if (self.connectionManager) {
            return self.connectionManager.getConnections(tag);
          }
          console.warn(
            "Party.getConnections was invoked before first connection. This will always return an empty list."
          );
          return [].values();
        },
        analytics: MockAnalyticsDataset,
        /// @deprecated, supported for backwards compatibility only
        get connections() {
          console.warn(
            "Party.connections is deprecated and will be removed in a future version of PartyKit. Use Party.getConnections() instead."
          );
          if (self.connectionManager) {
            return self.connectionManager.legacy_getConnectionMap();
          }
          console.warn(
            "Party.connections was invoked before first connection. This will always return an empty Map."
          );
          return /* @__PURE__ */ new Map();
        },
        get parties() {
          console.warn(
            "Party.parties is deprecated and will be removed in a future version of PartyKit. Use Party.context.parties instead."
          );
          return this.context.parties;
        },
      };
    }
    broadcast = (msg, without = []) => {
      if (!this.connectionManager) {
        return;
      }
      for (const connection of this.connectionManager.getConnections()) {
        if (!without.includes(connection.id)) {
          connection.send(msg);
        }
      }
    };
    async fetch(req) {
      const request = req;
      const url = new URL(request.url);
      try {
        if (!this.worker) {
          await this.initialize(request.url);
        }
        assert(this.worker, "Worker not initialized.");
        assert(this.connectionManager, "ConnectionManager not initialized.");
        if (request.headers.get("upgrade")?.toLowerCase() !== "websocket") {
          return await this.worker.onRequest(request);
        }
      } catch (e) {
        console.error("onRequest error", e);
        const errMessage = e instanceof Error ? e.message : `${e}`;
        const errCode = "code" in e ? e.code : 500;
        return new Response(
          errMessage || "Uncaught exception when making a request",
          {
            status: errCode,
          }
        );
      }
      try {
        if (
          !(
            ("onConnect" in this.worker &&
              typeof this.worker.onConnect === "function") ||
            ("onMessage" in this.worker &&
              typeof this.worker.onMessage === "function")
          )
        ) {
          throw new Error("No onConnect or onMessage handler");
        }
        const { 0: clientWebSocket, 1: serverWebSocket } = new WebSocketPair();
        let connectionId = url.searchParams.get("_pk");
        if (!connectionId) {
          connectionId = crypto.randomUUID();
        }
        let connection = Object.assign(serverWebSocket, {
          id: connectionId,
          socket: serverWebSocket,
          uri: request.url,
          state: null,
          setState(setState) {
            let state;
            if (setState instanceof Function) {
              state = setState(this.state);
            } else {
              state = setState;
            }
            this.state = state;
            return this.state;
          },
        });
        const ctx = { request };
        const tags = await this.worker.getConnectionTags(connection, ctx);
        connection = this.connectionManager.accept(connection, tags);
        if (!this.worker.supportsHibernation) {
          await this.attachSocketEventHandlers(connection);
        }
        await this.worker.onConnect(connection, ctx);
        return new Response(null, { status: 101, webSocket: clientWebSocket });
      } catch (e) {
        console.error("Error when connecting");
        console.error(e);
        const errMessage = e instanceof Error ? e.message : `${e}`;
        const pair = new WebSocketPair();
        pair[1].accept();
        pair[1].close(1011, errMessage || "Uncaught exception when connecting");
        return new Response(null, { status: 101, webSocket: pair[0] });
      }
    }
    /**
     * Parties can only be created once we have a request URL.
     * This method should be called when the durable object receives its
     * first connection, or is woken up from hibernation.
     */
    async initialize(requestUri) {
      this.#initializeParty(requestUri);
      return this.#initializeWorker();
    }
    #initializeParty(requestUri) {
      const url = new URL(requestUri);
      const roomId = getRoomAndPartyFromPathname2(url.pathname)?.room;
      assert(roomId, "No room id found in request url");
      this.id = roomId;
      this.parties = createMultiParties(this.namespaces, {
        host: url.host,
      });
    }
    async #initializeWorker() {
      this.worker = isClassAPI
        ? new ClassWorker(Worker2, this.room)
        : new ModuleWorker(Worker2, this.room);
      this.connectionManager = this.worker.supportsHibernation
        ? new HibernatingConnectionManager(this.controller)
        : new InMemoryConnectionManager();
      return this.worker.onStart();
    }
    async attachSocketEventHandlers(connection) {
      assert(this.worker, "[onConnect] Worker not initialized.");
      const handleMessageFromClient = (event) => {
        this.invokeOnMessage(connection, event.data).catch((e) => {
          console.error(e);
        });
      };
      const handleCloseFromClient = () => {
        connection.removeEventListener("message", handleMessageFromClient);
        connection.removeEventListener("close", handleCloseFromClient);
        this.invokeOnClose(connection).catch((e) => {
          console.error(e);
        });
      };
      const handleErrorFromClient = (e) => {
        connection.removeEventListener("message", handleMessageFromClient);
        connection.removeEventListener("error", handleErrorFromClient);
        this.invokeOnError(connection, e.error).catch((e2) => {
          console.error(e2);
        });
      };
      connection.addEventListener("close", handleCloseFromClient);
      connection.addEventListener("error", handleErrorFromClient);
      connection.addEventListener("message", handleMessageFromClient);
    }
    /** Runtime calls webSocketMessage when hibernated connection receives a message  */
    async webSocketMessage(ws, msg) {
      const connection = createLazyConnection(ws);
      if (!this.worker || import.meta.env.DEV) {
        assert(connection.uri, "No uri found in connection");
        await this.initialize(connection.uri);
      }
      return this.invokeOnMessage(connection, msg);
    }
    /** Runtime calls webSocketClose when hibernated connection closes  */
    async webSocketClose(ws) {
      const connection = createLazyConnection(ws);
      if (!this.worker || import.meta.env.DEV) {
        assert(connection.uri, "No uri found in connection");
        await this.initialize(connection.uri);
      }
      return this.invokeOnClose(connection);
    }
    /** Runtime calls webSocketError when hibernated connection errors  */
    async webSocketError(ws, err) {
      const connection = createLazyConnection(ws);
      if (!this.worker || import.meta.env.DEV) {
        assert(connection.uri, "No uri found in connection");
        await this.initialize(connection.uri);
      }
      return this.invokeOnError(connection, err);
    }
    async invokeOnClose(connection) {
      assert(this.worker, "[onClose] Worker not initialized.");
      return this.worker.onClose(connection);
    }
    async invokeOnError(connection, err) {
      assert(this.worker, "[onError] Worker not initialized.");
      return this.worker.onError(connection, err);
    }
    async invokeOnMessage(connection, msg) {
      if (!this.worker || import.meta.env.DEV) {
        assert(connection.uri, "No uri found in connection");
        await this.initialize(connection.uri);
      }
      console.log("INVOKE ON MESSAGE", this.worker);
      assert(this.worker, "[onMessage] Worker not initialized.");
      return this.worker.onMessage(msg, connection);
    }
    async alarm() {
      if (!this.worker || import.meta.env.DEV) {
        await this.#initializeWorker();
        assert(this.worker, "[onAlarm] Worker not initialized.");
      }
      try {
        this.inAlarm = true;
        return await this.worker.onAlarm();
      } finally {
        this.inAlarm = false;
      }
    }
  };
}
var Workers = {
  main: Worker,
};

var PartyKitDurable = createDurable(Worker, { name: "main" });
__PARTIES__;
var source_default = {
  async fetch(request, env, ctx) {
    try {
      const url = new URL(request.url);
      const {
        PARTYKIT_AI,
        PARTYKIT_DURABLE,
        PARTYKIT_VECTORIZE,
        PARTYKIT_CRONS,
        ...namespaces
      } = env;
      Object.assign(namespaces, {
        main: PARTYKIT_DURABLE,
      });
      const { room: roomId, party: targetParty } =
        getRoomAndPartyFromPathname2(url.pathname) || {};
      const parties2 = createMultiParties(namespaces, {
        host: url.host,
      });
      const vectorizeBindings = Object.fromEntries(
        Object.entries(PARTYKIT_VECTORIZE || {}).map(([key, value]) => [
          key,
          new VectorizeClient(value),
        ])
      );
      if (roomId) {
        assert(targetParty, "No party found in request url");
        const targetWorker = Workers[targetParty];
        const targetDurable = namespaces[targetParty];
        if (!targetWorker) {
          return new Response(`Party ${targetParty} not found`, {
            status: 404,
          });
        }
        const WorkerInstanceMethods = isClassWorker(targetWorker)
          ? targetWorker.prototype
          : targetWorker;
        if (request.headers.get("upgrade")?.toLowerCase() === "websocket") {
          let connectionId = url.searchParams.get("_pk");
          if (!connectionId) {
            connectionId = crypto.randomUUID();
          }
          let onBeforeConnectResponse = void 0;
          if ("onBeforeConnect" in targetWorker) {
            if (typeof targetWorker.onBeforeConnect === "function") {
              try {
                const mutableRequest = new Request(request.url, request);
                onBeforeConnectResponse = await targetWorker.onBeforeConnect(
                  mutableRequest,
                  {
                    id: roomId,
                    env: extractVars(env),
                    ai: PARTYKIT_AI,
                    assets: {
                      fetch(path) {
                        return assetsFetch(path, env, ctx);
                      },
                    },
                    parties: parties2,
                    vectorize: vectorizeBindings,
                    analytics: MockAnalyticsDataset,
                    bindings: getBindings(env),
                  },
                  ctx
                );
              } catch (e) {
                console.error("onBeforeConnect error", e);
                return new Response(
                  e instanceof Error ? e.message : `${e}` || "Unauthorised",
                  {
                    status: 401,
                  }
                );
              }
            } else {
              throw new Error(".onBeforeConnect must be a function");
            }
          }
          const docId = targetDurable.idFromName(roomId).toString();
          const id = targetDurable.idFromString(docId);
          if (onBeforeConnectResponse) {
            if (onBeforeConnectResponse instanceof Response) {
              return onBeforeConnectResponse;
            } else if (onBeforeConnectResponse instanceof Request) {
              return await targetDurable.get(id).fetch(onBeforeConnectResponse);
            }
          }
          return await targetDurable.get(id).fetch(request);
        } else {
          let onBeforeRequestResponse = request;
          if ("onBeforeRequest" in targetWorker) {
            if (typeof targetWorker.onBeforeRequest === "function") {
              try {
                const mutableRequest = new Request(request.url, request);
                onBeforeRequestResponse = await targetWorker.onBeforeRequest(
                  mutableRequest,
                  {
                    id: roomId,
                    env: extractVars(env),
                    ai: PARTYKIT_AI,
                    parties: parties2,
                    assets: {
                      fetch(path) {
                        return assetsFetch(path, env, ctx);
                      },
                    },
                    vectorize: vectorizeBindings,
                    analytics: MockAnalyticsDataset,
                    bindings: getBindings(env),
                  },
                  ctx
                );
              } catch (e) {
                console.error("onBeforeRequest error", e);
                return new Response(
                  e instanceof Error ? e.message : `${e}` || "Unauthorised",
                  {
                    status: 401,
                  }
                );
              }
            } else {
              throw new Error(".onBeforeRequest must be a function");
            }
          }
          if (onBeforeRequestResponse instanceof Response) {
            return onBeforeRequestResponse;
          }
          if (!("onRequest" in WorkerInstanceMethods)) {
            throw new Error("No onRequest handler");
          }
          const docId = targetDurable.idFromName(roomId).toString();
          const id = targetDurable.idFromString(docId);
          return await targetDurable.get(id).fetch(onBeforeRequestResponse);
        }
      } else {
        if (
          request.headers.get("upgrade")?.toLowerCase() === "websocket" &&
          Worker.onSocket
        ) {
          const { 0: clientWebSocket, 1: serverWebSocket } =
            new WebSocketPair();
          const connection = serverWebSocket;
          connection.request = request;
          connection.accept();
          await Worker.onSocket(
            connection,
            {
              env: extractVars(env),
              ai: PARTYKIT_AI,
              parties: parties2,
              vectorize: vectorizeBindings,
              analytics: MockAnalyticsDataset,
              assets: {
                fetch(path) {
                  return assetsFetch(path, env, ctx);
                },
              },
              bindings: getBindings(env),
            },
            ctx
          );
          return new Response(null, {
            status: 101,
            webSocket: clientWebSocket,
          });
        }
        const staticAssetsResponse = await fetchStaticAsset(request, env, ctx);
        const onFetch =
          Worker.onFetch ?? // eslint-disable-next-line deprecation/deprecation
          Worker.unstable_onFetch;
        const onCron = Worker.onCron;
        if (url.pathname === "/__scheduled__" && typeof onCron === "function") {
          const cronName = url.searchParams.get("cron") || "unknown";
          const cron =
            Object.entries(PARTYKIT_CRONS).find(
              ([name, _val]) => name === cronName
            )?.[1] || "* * * * *";
          await onCron(
            {
              scheduledTime: Date.now(),
              cron,
              name: cronName,
              noRetry() {
                throw new Error("Not implemented");
              },
            },
            {
              env: extractVars(env),
              ai: PARTYKIT_AI,
              parties: parties2,
              vectorize: vectorizeBindings,
              analytics: MockAnalyticsDataset,
              assets: {
                fetch(path) {
                  return assetsFetch(path, env, ctx);
                },
              },
              bindings: getBindings(env),
            },
            ctx
          );
          return new Response(`ran cron ${cronName}: ${cron}`, { status: 200 });
        }
        if (staticAssetsResponse) {
          return staticAssetsResponse;
        } else if (typeof onFetch === "function") {
          const fetchResponse = await onFetch(
            request,
            {
              env: extractVars(env),
              ai: PARTYKIT_AI,
              parties: parties2,
              vectorize: vectorizeBindings,
              analytics: MockAnalyticsDataset,
              assets: {
                fetch(path) {
                  return assetsFetch(path, env, ctx);
                },
              },
              bindings: getBindings(env),
            },
            ctx
          );
          if (fetchResponse) {
            return fetchResponse;
          }
        }
        const notFoundResponse = await assetsFetch("/404.html", env, ctx);
        if (notFoundResponse) {
          return new Response(notFoundResponse.body, {
            status: 404,
            statusText: "Not Found",
            headers: notFoundResponse.headers,
          });
        }
        return new Response("Not found", {
          status: 404,
        });
      }
    } catch (e) {
      console.warn("fetch error", e);
      return new Response(e instanceof Error ? e.message : `${e}`, {
        status: 500,
      });
    }
  },
  async scheduled(controller, env, ctx) {
    const {
      PARTYKIT_AI,
      PARTYKIT_DURABLE,
      PARTYKIT_VECTORIZE,
      PARTYKIT_CRONS,
      ...namespaces
    } = env;
    Object.assign(namespaces, {
      main: PARTYKIT_DURABLE,
    });
    const onCron = Worker.onCron;
    if (typeof onCron === "function") {
      const vectorizeBindings = Object.fromEntries(
        Object.entries(PARTYKIT_VECTORIZE || {}).map(([key, value]) => [
          key,
          new VectorizeClient(value),
        ])
      );
      const parties2 = createMultiParties(namespaces, {
        host: PARTYKIT_HOST,
      });
      const cron = controller.cron;
      const cronName =
        Object.entries(PARTYKIT_CRONS).find(
          ([_name, val]) => val === cron
        )?.[0] || "unknown";
      return onCron(
        Object.assign(controller, {
          name: cronName,
        }),
        {
          env: extractVars(env),
          ai: PARTYKIT_AI,
          parties: parties2,
          vectorize: vectorizeBindings,
          analytics: MockAnalyticsDataset,
          assets: {
            fetch(path) {
              return assetsFetch(path, env, ctx);
            },
          },
          bindings: getBindings(env),
        },
        ctx
      );
    }
  },
};
export { PartyKitDurable, source_default as default };
